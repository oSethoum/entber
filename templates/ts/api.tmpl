import { API, ID, Response, Event } from "./types";
import WebSocket from "reconnecting-websocket";

type Callback<T = any> = (data: T) => void;

export interface EntberInit {
  headers?: HeadersInit;
  mode?: RequestMode;
}

const stringify = (data: any) => JSON.stringify(data);
const parse = (data: string) => JSON.parse(data);

export class Entber {
  private socket?: WebSocket;
  private callbacks?: Map<string, Callback[]>;
  private readonly url: string;
  static instance?: Entber;
  private accessToken?: string;
  getAccessToken = () => {
    if (!this.accessToken) {
      this.accessToken = localStorage.getItem("accessToken") || "";
    }
    return this.accessToken;
  };

  cleanup() {
    localStorage.removeItem("accessToken");
    this.accessToken = undefined;
    this.socket?.close();
  }

  static getInstance(url: string) {
    if (!Entber.instance) {
      Entber.instance = new Entber(url);
    }
    return Entber.instance;
  }

  private ws() {
    if (this.socket) return;
    const wsUrl =
      this.url.replace(/^http/, "ws") + "/ws/listen?accessToken=" + this.getAccessToken();
    this.socket = new WebSocket(wsUrl);
    this.socket.onopen = () => {
      this.callbacks = new Map<string, Callback[]>();
    };

    this.socket.onerror = (e) => {
      console.error(e);
    };

    this.socket.onclose = () => {};

    this.socket.onmessage = (e) => {
      const message = parse(e.data);
      console.log(message);

      switch (message.kind) {
        case "notify":
          this.callbacks
            ?.get(message.event)
            ?.forEach((callback) => callback(message.content));
          break;
      }
    };
  }

  private constructor(url: string) {
    this.url = url.replace(/\/+$/, "");
  }

  getUrl() {
    return this.url;
  }

  async request(url: string, init?: RequestInit): Promise<Response<any>> {
    const method = init?.method || "GET";
    const headers = {
      ...init?.headers,
      authorization: this.getAccessToken(),
    };

    let response = await fetch(`${this.url}${url}`, {
      method,
      ...init,
      headers,
    });

    const json = await response.json();
    console.log(json);
    return json;
  }

  async findFile(filename: string) {
    return await this.request("/file/" + filename);
  }

  async createFile(file: File) {
    const formData = new FormData();
    formData.append("file", file);
    return await this.request("/files", {
      method: "POST",
      body: formData,
    });
  }

  async updateFile(filename: string, file: File) {
    const formData = new FormData();
    formData.append("file", file);
    return await this.request("/files/" + filename, {
      method: "PATCH",
      body: formData,
    });
  }

  async deleteFile(filename: string) {
    return await this.request("/files/" + filename, {
      method: "DELETE",
    });
  }

  async findOne<T extends keyof API>(
    resource: T,
    id: ID
  ): Promise<Response<API[T]["entity"]>> {
    const url = `/${String(resource)}/${id}`;
    return await this.request(url);
  }

  async findMany<T extends keyof API>(
    resource: T,
    query?: API[T]["queryInput"]
  ): Promise<Response<Array<API[T]["entity"]>>> {
    const url = `/${String(resource)}/${
      query ? `?query=${JSON.stringify(query)}` : ""
    }`;
    return await this.request(url);
  }

  async createOne<T extends keyof API>(
    resource: T,
    input: API[T]["createInput"]
  ): Promise<Response<API[T]["entity"]>> {
    const url = `/${String(resource)}/`;
    const body = JSON.stringify(input);
    return await this.request(url, {
      method: "POST",
      body,
      headers: { "content-type": "application/json" },
    });
  }

  async createMany<T extends keyof API>(
    resource: T,
    input: API[T]["createInput"][]
  ): Promise<Response<API[T]["entity"][]>> {
    const url = `/${String(resource)}/bulk`;
    const body = JSON.stringify(input);
    return await this.request(url, {
      method: "POST",
      body,
      headers: { "content-type": "application/json" },
    });
  }

  async updateOne<T extends keyof API>(
    resource: T,
    id: ID,
    input: API[T]["updateInput"]
  ): Promise<Response<API[T]["entity"]>> {
    const url = `/${String(resource)}/${id}`;
    const body = JSON.stringify(input);
    return await this.request(url, {
      method: "PATCH",
      body,
      headers: { "content-type": "application/json" },
    });
  }

  async updateMany<T extends keyof API>(
    resource: T,
    input: API[T]["updateInput"],
    where?: API[T]["whereInput"]
  ): Promise<Response<undefined>> {
    const url = `/${String(resource)}/${
      where ? `?${JSON.stringify(where)}` : ""
    }`;
    const body = JSON.stringify(input);
    return await this.request(url, {
      method: "PATCH",
      body,
      headers: { "content-type": "application/json" },
    });
  }

  async deleteOne<T extends keyof API>(
    resource: T,
    id: ID
  ): Promise<Response<undefined>> {
    const url = `/${String(resource)}/${id}`;
    return await this.request(url, { method: "DELETE" });
  }

  async deleteMany<T extends keyof API>(
    resource: T,
    where?: API[T]["whereInput"]
  ): Promise<Response<undefined>> {
    const url = `/${String(resource)}/${
      where ? `?${JSON.stringify(where)}` : ""
    }`;
    return await this.request(url, { method: "DELETE" });
  }

  async subscribe<T extends keyof API>(
    resource: T,
    event: Event,
    callback: Callback
  ) {
    this.ws();
    this.socket?.send(
      stringify({ event: `${resource}:${event}`, kind: "subscribe" })
    );

    this.callbacks?.set(`${resource}:${event}`, [
      ...(this.callbacks.get(`${resource}${event}`) || []),
      callback,
    ]);
  }

  async unsubscribe<T extends keyof API>(resource: T, event: Event) {
    this.socket?.send(
      stringify({ event: `${resource}:${event}`, kind: "unsubscribe" })
    );
    this.callbacks?.delete(`${resource}:${event}`);
  }

  async unsubscribeAll() {
    this.socket?.send(stringify({ kind: "unsubscribe-all" }));
    this.callbacks?.clear();
  }
}
