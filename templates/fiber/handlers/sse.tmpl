package handlers

import (
	"{{ dir .Package }}/config"
	"bufio"
	"fmt"
	"strings"
	"sync"

	"aidanwoods.dev/go-paseto"
	"github.com/goccy/go-json"
	"github.com/gofiber/fiber/v2"
	"github.com/rs/xid"
	"github.com/valyala/fasthttp"
)

var listeners = make(map[string]chan any)
var events = make(map[string]string)
var listennersM = sync.Mutex{}
var eventsM = sync.Mutex{}

func Listen(ctx *fiber.Ctx) error {
	_, err := paseto.NewParser().ParseV4Local(config.AccessKey, ctx.Query("token"), config.AccessSecret)
	if err != nil {
		return StopWithError(ctx, err, fiber.StatusUnauthorized)
	}
	c := ctx.Context()
	c.SetContentType("text/event-stream")
	c.Response.Header.Set("Cache-Control", "no-cache")
	c.Response.Header.Set("Connection", "keep-alive")
	c.Response.Header.Set("Transfer-Encoding", "chunked")
	c.Response.Header.Set("Access-Control-Allow-Headers", "Cache-Control")
	c.Response.Header.Set("Access-Control-Allow-Credentials", "true")

	ch := make(chan any, 1)
	id := xid.New().String()
	listennersM.Lock()
	listeners[id] = ch
	listennersM.Unlock()

	c.SetBodyStreamWriter(fasthttp.StreamWriter(func(w *bufio.Writer) {
		fmt.Fprintf(w, "event: id\ndata: %s\n\n", id)
		err := w.Flush()
		if err != nil {
			return
		}
		for {
			data := <-ch
			msg := fmt.Sprintf("the time is %v", data)
			fmt.Fprintf(w, "data: Message: %s\n\n", msg)
			err := w.Flush()
			if err != nil {
				return
			}
		}
	}))

	return nil
}

func Subscribe(ctx *fiber.Ctx) error {
	id := ctx.Params("id")

	body := new(struct {
		Event string `json:"event"`
		Mode  string `json:"mode"`
	})

	err := ctx.BodyParser(body)
	if err != nil {
		StopWithError(ctx, err)
	}

	eventsM.Lock()
	switch body.Mode {
	case "subscribe":
		if !strings.Contains(events[id], body.Event) {
			events[id] += " " + body.Event
		}
	case "unsubscribe":
		if strings.Contains(events[id], body.Event) {
			events[id] = strings.ReplaceAll(events[id], " "+body.Event, "")
		}
	case "unsibscribe-all":
		events[id] = ""
	}
	eventsM.Unlock()

	return ctx.Status(fiber.StatusOK).JSON(fiber.Map{
		"code":   fiber.StatusOK,
		"status": "success",
	})
}

func Notify(event string, response any) {
	data, _ := json.Marshal(response)
	eventsM.Lock()
	for id, evs := range events {
		if strings.Contains(evs, event) {
			listennersM.Lock()
			listeners[id] <- data
			listennersM.Unlock()
		}
	}
	eventsM.Unlock()
}
