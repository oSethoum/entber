package handlers

import (
	"{{ dir .Package }}/config"
	"bufio"
	"fmt"
	"strings"
	"sync"

	"aidanwoods.dev/go-paseto"
	"github.com/goccy/go-json"
	"github.com/gofiber/fiber/v2"
	"github.com/rs/xid"
	"github.com/valyala/fasthttp"
)


type bus struct {
	mode string
	data any
}

var listeners = make(map[string]chan bus)
var events = make(map[string]string)
var listenersM = sync.Mutex{}
var eventsM = sync.Mutex{}

func clean(id string) {
	listenersM.Lock()
	delete(listeners, id)
	listenersM.Unlock()
	eventsM.Lock()
	delete(events, id)
	eventsM.Unlock()
}

func Listen(ctx *fiber.Ctx) error {
	_, err := paseto.NewParser().ParseV4Local(config.AccessKey, ctx.Query("token"), config.AccessSecret)
	if err != nil {
		return StopWithError(ctx, err, fiber.StatusUnauthorized)
	}
	c := ctx.Context()
	c.SetContentType("text/event-stream")
	c.Response.Header.Set("Cache-Control", "no-cache")
	c.Response.Header.Set("Connection", "keep-alive")
	c.Response.Header.Set("Transfer-Encoding", "chunked")
	c.Response.Header.Set("Access-Control-Allow-Headers", "Cache-Control")
	c.Response.Header.Set("Access-Control-Allow-Credentials", "true")

	ch := make(chan bus, 1)
	id := xid.New().String()
	listenersM.Lock()
	listeners[id] = ch
	listenersM.Unlock()

	c.SetBodyStreamWriter(fasthttp.StreamWriter(func(w *bufio.Writer) {
		fmt.Fprintf(w, "event: id\ndata: %s\n\n", id)
		err := w.Flush()
		if err == nil {
			for {
				bs := <-ch
				if bs.mode == "close" {
					break
				} else {
					msg := fmt.Sprintf("the time is %v", bs.data)
					fmt.Fprintf(w, "data: Message: %s\n\n", msg)
					err := w.Flush()
					if err != nil {
						return
					}
				}
			}
		}

	}))

	clean(id)
	return nil
}

func Subscribe(ctx *fiber.Ctx) error {
	id := ctx.Params("id")

	body := new(struct {
		Event string `json:"event"`
		Mode  string `json:"mode"`
	})

	err := ctx.BodyParser(body)
	if err != nil {
		StopWithError(ctx, err)
	}

	eventsM.Lock()
	switch body.Mode {
	case "subscribe":
		if !strings.Contains(events[id], body.Event) {
			events[id] += " " + body.Event
		}
	case "unsubscribe":
		if strings.Contains(events[id], body.Event) {
			events[id] = strings.ReplaceAll(events[id], " "+body.Event, "")
		}
	case "unsubscribe-all":
		events[id] = ""
	case "close":
		listenersM.Lock()
		listeners[id] <- bus{mode: "close"}
		listenersM.Unlock()
	}

	eventsM.Unlock()

	return ctx.Status(fiber.StatusOK).JSON(fiber.Map{
		"code":   fiber.StatusOK,
		"status": "success",
	})
}

func Notify(event string, response any) {
	data, _ := json.Marshal(response)
	fmt.Printf("%+v\n", events)
	eventsM.Lock()
	for id, evs := range events {
		if strings.Contains(evs, event) {
			listenersM.Lock()
			listeners[id] <- bus{mode: "notify", data: data}
			println("id", id, "event", event)
			listenersM.Unlock()
		}
	}
	eventsM.Unlock()
}
