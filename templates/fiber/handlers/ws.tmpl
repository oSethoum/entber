package handlers

import (
	"fmt"
	"strings"
	"sync"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/websocket/v2"
)

type Kind = string

const (
	Subscribe      Kind = "subscribe"
	Unsubscribe    Kind = "unsubscribe"
	UnsubscribeAll Kind = "unsubscribe-all"
	Connected      Kind = "connected"
	Notify         Kind = "notify"
)

type Message struct {
	Kind    Kind   `json:"kind,omitempty"`
	Event   string `json:"event,omitempty"`
	Content any    `json:"content,omitempty"`
}

var subs = map[string]int{}
var mutex = sync.Mutex{}
var bus = make(chan Message)

func increase(event string) {
	mutex.Lock()
	subs[event]++
	fmt.Printf("increase \nsubs: %+v\n", subs)
	mutex.Unlock()
}

func decrease(event string) {
	mutex.Lock()
	subs[event]--
	if subs[event] == 0 {
		delete(subs, event)
	}
	fmt.Printf("decrease \nsubs: %+v\n", subs)
	mutex.Unlock()
}

func cleanup(events string) {
	for _, ev := range strings.Split(events, " ") {
		decrease(ev)
	}
}

func trim(s string) string {
	trimFn := func(r rune) bool {
		return r == ' '
	}
	s = strings.TrimLeftFunc(s, trimFn)
	s = strings.TrimRightFunc(s, trimFn)
	return s
}

func Listen(c *websocket.Conn) {
	events := ""
	done := make(chan bool, 1)

	err := c.WriteJSON(Message{Kind: "connected"})
	println(c, "Connected")
	if err != nil {
		go func() {
			done <- true
		}()
	}
	go func() {
		m := new(Message)
		for {
			err := c.ReadJSON(m)
			if err != nil {
				done <- true
			}
			fmt.Printf("%+v\n", m)
			if m.Kind == Subscribe {
				evs := strings.Split(trim(m.Event), " ")
				for _, ev := range evs {
					if !strings.Contains(events, ev) {
						increase(ev)
						events = trim(events + " " + ev)
					}
				}
			}

			if m.Kind == Unsubscribe {
				evs := strings.Split(trim(m.Event), " ")
				for _, ev := range evs {
					if strings.Contains(events, ev) {
						decrease(ev)
						events = trim(strings.ReplaceAll(events, ev, ""))
					}
				}
			}

			if m.Kind == UnsubscribeAll {
				cleanup(events)
				events = ""
			}
		}
	}()

	for {
		select {
		case m := <-bus:
			c.WriteJSON(m)

		case <-done:
			cleanup(events)
			println(c, "Disconnected")
			return
		}
	}
}

func Broadcast(event string, data any) {
	for i := 0; i < subs[event]; i++ {
		bus <- Message{Kind: Notify, Event: event, Content: data}
	}
}

func Upgrade(ctx *fiber.Ctx) error {
	if websocket.IsWebSocketUpgrade(ctx) {
		return ctx.Next()
	}
	return fiber.ErrUpgradeRequired
}
